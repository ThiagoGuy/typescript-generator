<html>

<head>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<style>
		html,
		body {
			height: 100%;
		}

		body {
			color: #fff;
			background-color: rgba(0, 0, 0, 0.959);
			font-size: 1.25rem;
			text-shadow: 0 2px 2px #90007e;
		}

		div {
			display: flex;
			flex-direction: column;
			justify-content: center;
		}

		h1 {
			font-size: 1.75rem;
			margin: 0 0 5px 0.75rem 0;
		}

		textarea {
			resize: none;
			max-height: 100%;
		}

		button {
			background-color: #1287c2;
		}

		.section {
			height: 100vh;
		}

		.section-options {
			padding: 30px 120px;
		}

		.section-menu {
			background-color: #101e29;
			padding: 50px;
			padding-left: 175px;
			border-radius: 5px;
		}

		.section-menu input[type="radio"],
		.section-menu input[type="checkbox"] {
			display: none;
		}

		.container-menu {
			margin-bottom: 15px;
		}

		.container-menu label {
			position: relative;
		}

		.container-menu span::before,
		.container-menu span::after {
			content: '';
			position: absolute;
			top: 0;
			bottom: 0;
			margin: auto;
		}

		.container-menu span.radio:hover {
			cursor: pointer;
		}

		.container-menu span.radio::before {
			left: -52px;
			width: 45px;
			height: 25px;
			background-color: #A8AAC1;
			border-radius: 50px;
		}

		.container-menu span.radio::after {
			left: -49px;
			width: 17px;
			height: 17px;
			border-radius: 10px;
			background-color: #6C788A;
			transition: left .3s, background-color .3s;
		}

		.container-menu input {
			margin-left: -100px;
			height: 25px;
		}

		input[type="radio"]:checked+label span.radio::after {
			left: -27px;
			background-color: rgb(233, 108, 6);
		}

		input {
			margin: 5px;
		}

		.btn {
			font-size: 14px;
			padding: 8px 24px;
			margin: 2px;
			border: none;
			border-radius: 2px;
			text-align: center;
			text-decoration: none;
			display: inline-block;
		}

		.btn:hover {
			cursor: pointer;
		}

		.btn-default {
			color: black;
			background-color: #e7e7e7;
			box-shadow: 0 1px 1px #90007e;
		}

		.btn-default:hover {
			background-color: #f8f8f8;
		}

		.container {
			text-align: center;
			display: flex;
			padding: 5px;
			margin: 0 5%;
		}

		.left-half {
			background-color: #6395bd;
			flex: 1;
			padding: 1rem;
			border-radius: 5px 0 0 5px;
		}

		.right-half {
			background-color: #174a71;
			flex: 1;
			padding: 1rem;
			border-radius: 0 5px 5px 0;
		}

		.title-menu {
			text-align: left;
			padding: 20px;
			padding-left: 50px;
		}

		.title {
			text-align: center;
			padding: 10px;
		}

		.footer {
			text-align: center;
			padding: 10px 0;
		}

		#optionButton {
			position: fixed;
			bottom: 10px;
			right: 10px;
		}

		#topButton {
			position: fixed;
			top: 10px;
			right: 10px;
		}

		@media (max-width: 920px) {
			textarea {
				max-height: 50%;
			}
			.container {
				display: inline;
				padding: 0;
				margin: 0;
			}
			.section-options {
				padding: 0;
			}

			.left-half {
				flex: none;
				border-radius: 5px 5px 0 0;
			}
			.right-half {
				flex: none;
				border-radius: 0 0 5px 5px;
			}

		}
	</style>
	<title>TS Generator</title>
</head>

<body>

	<div class="title">
		<h3>Typescript Generator</h3>
	</div>

	<section class="container">
		<div class="left-half">
			<article>
				<h1>Put your JSON</h1>

				<input id="rootClass" type="text" style="width: 80%" placeholder="Class name" />
				<textarea id="json" type="text" rows="25" style="width: 80%" placeholder="Paste your JSON here.."></textarea>
				<p>
					<input id="clearBtn" type="button" value="Clear" class="btn btn-default" />
					<input id="generateBtn" type="button" value="Generate" class="btn btn-default" />
				</p>
			</article>
		</div>
		<div class="right-half">
			<article>
				<h1>Watch the result</h1>
				<textarea id="result" type="text" rows="25" style="width: 80%" readonly></textarea>
				<p>
					<input id="copyBtn" type="button" value="Copy" class="btn btn-default" />
					<input id="downloadBtn" type="button" value="Download" class="btn btn-default" />
				</p>
			</article>
		</div>
	</section>

	<section class="section-options">

		<div class="title-menu">
			<h4>What kind of generator do you need?</h4>
		</div>
		<section id="generatorTypeSelect" class="section-menu">
			<div class="container-menu">
				<input type="radio" name="generatorType" value="class" id="radio-class-generator" checked="checked">
				<label for="radio-class-generator">
					<span class="radio">Class</span>
				</label>
			</div>
			<div class="container-menu">
				<input type="radio" name="generatorType" value="interface" id="radio-interface-generator">
				<label for="radio-interface-generator">
					<span class="radio">Interface</span>
				</label>
			</div>
			<div class="container-menu">
				<input type="radio" name="generatorType" value="setter" id="radio-setter-generator">
				<label for="radio-setter-generator">
					<span class="radio">Setter</span>
				</label>
			</div>
		</section>

		<div id="assignmentOption" style="display: none">
			<div class="title-menu">
				<h4>What kind of assignment do you need?</h4>
			</div>
			<section class="section-menu">
				<div class="container-menu">
					<input type="radio" name="assignments" value="assignmentSignal" id="radio-assignment" checked="checked">
					<label for="radio-assignment">
						<span class="radio">Assignment signal</span>
					</label>
				</div>
				<div class="container-menu">
					<input type="radio" name="assignments" value="setterMethod" id="radio-setter">
					<label for="radio-setter">
						<span class="radio">Setter method</span>
					</label>
				</div>
			</section>
		</div>

		<div id="arrayInstantiationOption" style="display: none">
			<div class="title-menu">
				<h4>Do you need to instantiate arrays?</h4>
			</div>
			<section class="section-menu">
				<div class="container-menu">
					<input type="radio" name="array-instantiation" value="true" id="radio-array-yes" checked="checked">
					<label for="radio-array-yes">
						<span class="radio">Yes</span>
					</label>
				</div>
				<div class="container-menu">
					<input type="radio" name="array-instantiation" value="false" id="radio-array-no">
					<label for="radio-array-no">
						<span class="radio">No, thanks</span>
					</label>
				</div>
			</section>
		</div>


		<div id="stringDataTypeOption" style="display: none">
			<div class="title-menu">
				<h4>Do you need to work only with the string data type?</h4>
			</div>
			<section class="section-menu">
				<div class="container-menu">
					<input type="radio" name="string-data-type" value="true" id="radio-string-yes" checked="checked">
					<label for="radio-string-yes">
						<span class="radio">Yes</span>
					</label>
				</div>
				<div class="container-menu">
					<input type="radio" name="string-data-type" value="false" id="radio-string-no">
					<label for="radio-string-no">
						<span class="radio">No, thanks</span>
					</label>
				</div>
			</section>
		</div>


		<div id="emptyStringOption" style="display: none">
			<div class="title-menu">
				<h4>Do you need to work only with empty string?</h4>
			</div>
			<section class="section-menu">
				<div class="container-menu">
					<input type="radio" name="empty-string" value="true" id="radio-empty-string-yes" checked="checked">
					<label for="radio-empty-string-yes">
						<span class="radio">Yes</span>
					</label>
				</div>
				<div class="container-menu">
					<input type="radio" name="empty-string" value="false" id="radio-empty-string-no">
					<label for="radio-empty-string-no">
						<span class="radio">No, thanks</span>
					</label>
				</div>
			</section>
		</div>


		<div id="encryptionAnnotationOption" style="display: none">
			<div class="title-menu">
				<h4>What kind of encryption annotation do you need?</h4>
			</div>
			<section class="section-menu">
				<div class="container-menu">
					<input type="radio" name="encryptionAnnotation" value="" id="radio-encryptionAnnotation-none" checked="checked">
					<label for="radio-encryptionAnnotation-none">
						<span class="radio">None</span>
					</label>
				</div>
				<div class="container-menu">
					<input type="radio" name="encryptionAnnotation" value="Encrypt" id="radio-encryptionAnnotation-encrypt">
					<label for="radio-encryptionAnnotation-encrypt">
						<span class="radio">Encrypt</span>
					</label>
				</div>
				<div class="container-menu">
					<input type="radio" name="encryptionAnnotation" value="Descrypt" id="radio-encryptionAnnotation-descrypt">
					<label for="radio-encryptionAnnotation-descrypt">
						<span class="radio">Descrypt</span>
					</label>
				</div>
			</section>

			<div class="title-menu">
				<h4>Where is the encryption annotation located?</h4>
			</div>
			<section class="section-menu">
				<div class="container-menu">
					<input id="encryptionAnnotationPath" type="text" placeholder="Path" />
				</div>
			</section>
		</div>



	</section>

	<div class="footer">
		<h5>version 4.2.0</h5>
	</div>

	<script>
		/* components */
		const generateBtn = document.querySelector("#generateBtn");
		const downloadBtn = document.querySelector("#downloadBtn");
		const clearBtn = document.querySelector("#clearBtn");
		const copyBtn = document.querySelector("#copyBtn");
		const rootClassInput = document.querySelector("#rootClass");
		const jsonInput = document.querySelector("#json");
		const resultInput = document.querySelector("#result");
		const generatorTypeSelect = document.querySelector("#generatorTypeSelect");

		let contents = [];

		class Options {
			supportAssignment() {
				return false;
			}

			supportStrigDataType() {
				return false;
			}

			supportArrayInstantiation() {
				return false;
			}

			supportEmptyString() {
				return false;
			}

			supportEncryptionAnnotation() {
				return false;
			}
		}

		class SetterOptions extends Options {

			constructor() {
				super();
				this.assignment = "";
				this.arrayInstantiation = "";
				this.stringDataType = "";
				this.emptyString = "";
			}

			canInstantiateArray() {
				return this.arrayInstantiation == "true";
			}

			canUseOnlyStrigDataType() {
				return this.stringDataType == "true";
			}

			canUseEmptyString() {
				return this.emptyString == "true";
			}

			supportAssignment() {
				return true;
			}

			supportStrigDataType() {
				return true;
			}

			supportArrayInstantiation() {
				return true;
			}

			supportEmptyString() {
				return true;
			}
		}

		class ClassOptions extends Options {
			constructor() {
				super();
				this.assignment = "";
				this.encryption = "";
				this.encryptionPath = "";
			}

			supportAssignment() {
				return true;
			}

			supportEncryptionAnnotation() {
				return true;
			}
		}

		class InterfaceOptions extends Options {
			constructor() {
				super();
			}
		}

		class Attribute {
			constructor(fieldName, fieldType, annotation) {
				this.fieldName = fieldName;
				this.fieldType = fieldType;
				this.annotation = annotation;
			}
		}

		class ArrayAttribute {
			constructor(fieldName, fieldType) {
				this.fieldName = fieldName;
				this.fieldType = fieldType;
			}
		}

		class Class {
			constructor(className) {
				this.imports = [];
				this.className = className;
				this.attributes = [];
				this.arrayAttributes = [];
			}
		}

		class Instance {
			constructor(fieldName, className) {
				this.fieldName = fieldName;
				this.className = className;
			}
		}

		class ArrayInstance {
			constructor(fieldName, fieldType) {
				this.fieldName = fieldName;
				this.fieldType = fieldType;
			}
		}

		class ArraySetter {
			constructor(fieldName, value) {
				this.fieldName = fieldName;
				this.value = value;
			}
		}

		class Setter {
			constructor(fieldName, methodName, value) {
				this.fieldName = fieldName;
				this.methodName = methodName;
				this.value = value;
			}
		}

		class Import {
			constructor(className, path) {
				this.className = className;
				this.path = path;
			}
		}

		class Content {
			constructor(name, text) {
				this.name = name;
				this.text = text;
			}
		}

		class Generator {

			constructor(options, writer) {

				if (!options) {
					showError("Options cannot be empty.");
				}

				if (!writer) {
					showError("The writer cannot be null.");
				}

				this._options = options;
				this._writer = writer;
			}

		}

		class ClassGenerator extends Generator {

			constructor(classOptions, classWriter) {
				super(classOptions, classWriter);
				this._classList = [];
			}

			create(json, fieldName) {

				if (!json) {
					return;
				}

				if (Utils.isBlank(fieldName)) {
					showError("Class name cannot be blank.");
				}

				const className = Utils.getClassName(fieldName);
				const clazz = new Class(className);
				this._classList.push(clazz);
				let isEncryptionImportApplied;

				for (let field in json) {

					if (Utils.isBlank(field)) {
						showError("Field name cannot be blank.");
					}

					const val = json[field];
					const isFieldAnArray = Array.isArray(val);
					field = Utils.fixFieldName(field);

					if (isFieldAnArray) {
						const isFieldAnObject = Utils.isObject(val[0]);
						const fieldType = Utils.getType(val[0]);

						if (isFieldAnObject) {
							clazz.imports.push(new Import(Utils.getClassName(field), `./${field}`));
							clazz.arrayAttributes.push(new ArrayAttribute(field, Utils.getClassName(field)));
							this.create(val[0], field);
						} else {
							clazz.arrayAttributes.push(new ArrayAttribute(field, fieldType));
						}

					} else {
						const isFieldAnObject = Utils.isObject(val);
						const fieldType = Utils.getType(val);

						if (isFieldAnObject) {
							clazz.imports.push(new Import(Utils.getClassName(field), `./${field}`));
							clazz.attributes.push(new Attribute(field, Utils.getClassName(field)));
							this.create(val, field);
						} else {
							const isEncrypted = Utils.isBase64(val);

							if (this._options.encryption && isEncrypted) {
								clazz.attributes.push(new Attribute(field, fieldType, this._options.encryption));

								if (!isEncryptionImportApplied && this._options.encryptionPath) {
									clazz.imports.push(new Import(this._options.encryption, this._options.encryptionPath));
									isEncryptionImportApplied = true;
								}
							} else {
								clazz.attributes.push(new Attribute(field, fieldType));
							}
						}

					}
				}

			}

			build() {
				const contents = [];
				const assignment = this._options.assignment;

				this._classList.forEach(clazz => {

					clazz.imports.forEach(imp => {
						this._writer.writeImport(imp);
					});

					this._writer.writeLine();
					this._writer.writeStartClass(clazz);

					if (assignment == "setterMethod") {
						clazz.attributes.forEach(attr => {
							if (attr.annotation) {
								this._writer.writeAnnotation(attr.annotation);
							}
							this._writer.writeSetterAttribute(attr);
						});
						clazz.arrayAttributes.forEach(arrAttr => this._writer.writeSetterArrayAttribute(arrAttr));
						this._writer.writeLine();

						clazz.attributes.forEach(attr => {
							this._writer.writeGetter(attr);
							this._writer.writeSetter(attr);
						});

						clazz.arrayAttributes.forEach(arrAttr => {
							this._writer.writeArrayGetter(arrAttr);
							this._writer.writeArraySetter(arrAttr)
						});

					} else {
						clazz.attributes.forEach(attr => {
							if (attr.annotation) {
								this._writer.writeAnnotation(attr.annotation);
							}
							this._writer.writeAttribute(attr);
						});
						clazz.arrayAttributes.forEach(arrAttr => this._writer.writeArrayAttribute(arrAttr));
					}

					this._writer.writeEndClass();
					this._writer.writeLine();

					contents.push(new Content(clazz.className, this._writer.toString()));
					this._writer.reset();
				});

				return contents;
			}

		}

		class SetterGenerator extends Generator {

			constructor(setterOptions, setterWriter) {
				super(setterOptions, setterWriter);
				this._fieldNameMap = new Map();
				this._instances = [];
				this._arrayInstances = [];
				this._instanceSetters = [];
				this._arrayInstanceSetters = [];
				this._arraySetters = [];
				this._setters = [];
			}

			create(json, fieldName, className) {

				if (!json) {
					return;
				}

				if (Utils.isBlank(fieldName)) {
					showError("Field name cannot be blank.");
				}

				fieldName = Utils.fixFieldName(fieldName);
				className = className || Utils.getClassName(fieldName);
				const isArray = Array.isArray(json);
				const nextFieldName = this._memorizeNextFieldName(fieldName);

				if (isArray) {
					let fieldType = Utils.getType(json[0]);

					if (fieldType == "object") {
						fieldType = className;
					}

					this._arrayInstances.push(new ArrayInstance(fieldName, fieldType));
				} else {
					this._instances.push(new Instance(nextFieldName, className));
				}

				for (let field in json) {

					if (Utils.isBlank(field)) {
						showError("Field name cannot be blank.");
					}

					const val = json[field];
					const isFieldAnObject = Utils.isObject(val);
					const isFieldAnArray = Array.isArray(val);

					if (!this._options.canInstantiateArray() && isFieldAnArray)
						continue;

					field = Utils.fixFieldName(field);

					if (isArray) {
						if (isFieldAnObject) {
							const name = Utils.getListFieldName(fieldName, val);
							this._arrayInstanceSetters.push(new ArraySetter(fieldName, this._generateNextFieldName(name)));
							this.create(val, name, Utils.getClassName(name));
						} else {
							this._arraySetters.push(new ArraySetter(nextFieldName,
								Utils.fixValue(val, this._options.canUseOnlyStrigDataType())));
						}

					} else {
						if (isFieldAnObject) {
							const name = Utils.getListFieldName(field, val);
							this._instanceSetters.push(new Setter(nextFieldName, field, name));
							this.create(val, name, Utils.getClassName(field));
						} else {
							if (this._options.canUseEmptyString() || val) {
								this._setters.push(new Setter(nextFieldName, field,
									Utils.fixValue(val, this._options.canUseOnlyStrigDataType())));
							}
						}

					}

				}
			}

			build() {
				const contents = [];
				const assignment = this._options.assignment;
				this._instances.forEach(i => this._writer.writeInstance(i));
				this._arrayInstances.forEach(ai => this._writer.writeArrayInstance(ai));
				this._writer.writeLine();

				if (assignment == "setterMethod") {
					this._instanceSetters.forEach(is => this._writer.writeSetter(is));
				} else {
					this._instanceSetters.forEach(is => this._writer.writeAssignment(is));
				}
				if (!Utils.isEmpty(this._instanceSetters)) this._writer.writeLine();

				this._arrayInstanceSetters.forEach(ais => this._writer.writeArraySetter(ais));
				if (!Utils.isEmpty(this._arrayInstanceSetters)) this._writer.writeLine();

				this._arraySetters.forEach(s => this._writer.writeArraySetter(s));
				if (!Utils.isEmpty(this._arraySetters)) this._writer.writeLine();

				if (assignment == "setterMethod") {
					this._setters.forEach(s => this._writer.writeSetter(s));
				} else {
					this._setters.forEach(s => this._writer.writeAssignment(s));
				}

				contents.push(new Content("Setters", this._writer.toString()));
				this._writer.reset();

				return contents;
			}

			_memorizeNextFieldName(fieldName) {
				let nextFieldName = this._generateNextFieldName(fieldName);
				this._fieldNameMap.set(fieldName, nextFieldName);
				return nextFieldName;
			}

			_generateNextFieldName(fieldName) {
				let fieldCounter = 0;
				let nextFieldName = fieldName;

				if (this._fieldNameMap.has(fieldName)) {
					const fieldNameFromMap = this._fieldNameMap.get(fieldName);
					if (fieldCounter = Utils.getNumberFromString(fieldNameFromMap)) {
						nextFieldName = fieldNameFromMap.replace(fieldCounter, Number(fieldCounter) + 1);
					} else {
						nextFieldName = fieldNameFromMap + "1";
					}
				}
				return nextFieldName;
			}

		}

		class Writer {

			constructor() {
				this._text = "";
			}

			writeLine() {
				this._write("\n");
			}

			_write(str) {
				this._text += str;
			}

			reset() {
				this._text = "";
			}

			toString() {
				return this._text;
			}

		}

		class ClassWriter extends Writer {

			// import { className } from 'path';
			writeImport(imp) {
				const syntax = `import { ${imp.className} } from '${imp.path}';`;

				this._write(syntax);
				this.writeLine();
			}

			// class className {
			writeStartClass(clazz) {
				const syntax = `export class ${clazz.className} {`;

				this._write(syntax);
				this.writeLine();
			}

			// }
			writeEndClass() {
				const syntax = "}";

				this._write(syntax);
				this.writeLine();
			}

			// @name
			writeAnnotation(name) {
				const syntax = `	@${name}`;

				this._write(syntax);
				this.writeLine();
			}

			// fieldName: fieldType;
			writeAttribute(attribute) {
				const syntax = `	${attribute.fieldName}: ${attribute.fieldType};`;

				this._write(syntax);
				this.writeLine();
			}

			// private _fieldName: fieldType;
			writeSetterAttribute(attribute) {
				const syntax = `	private _${attribute.fieldName}: ${attribute.fieldType};`;

				this._write(syntax);
				this.writeLine();
			}

			// fieldName: Array<fieldType> = [];
			writeArrayAttribute(arrayAttribute) {
				const syntax = `	${arrayAttribute.fieldName}: Array<${arrayAttribute.fieldType}> = [];`;

				this._write(syntax);
				this.writeLine();
			}

			// private _fieldName: Array<fieldType> = [];
			writeSetterArrayAttribute(arrayAttribute) {
				const syntax = `	private _${arrayAttribute.fieldName}: Array<${arrayAttribute.fieldType}> = [];`;

				this._write(syntax);
				this.writeLine();
			}

			// get fieldName(): fieldType {
			//	return this._fieldName;
			// }
			writeGetter(attribute) {
				const startSyntax = `	get ${attribute.fieldName}(): ${attribute.fieldType} {`;
				const middleSyntax = `		return this._${attribute.fieldName};`;
				const endSyntax = "	}";

				this._write(startSyntax);
				this.writeLine();
				this._write(middleSyntax);
				this.writeLine();
				this._write(endSyntax);
				this.writeLine();
			}

			// get fieldName(): fieldType[] {
			//	return this._fieldName;
			// }
			writeArrayGetter(attribute) {
				const startSyntax = `	get ${attribute.fieldName}(): ${attribute.fieldType}[] {`;
				const middleSyntax = `		return this._${attribute.fieldName};`;
				const endSyntax = "	}";

				this._write(startSyntax);
				this.writeLine();
				this._write(middleSyntax);
				this.writeLine();
				this._write(endSyntax);
				this.writeLine();
			}

			// set fieldName(fieldName: fieldType) {
			//	this._fieldName = fieldName;
			// }
			writeSetter(attribute) {
				const startSyntax = `	set ${attribute.fieldName}(${attribute.fieldName}: ${attribute.fieldType}) {`;
				const middleSyntax = `		this._${attribute.fieldName} = ${attribute.fieldName};`;
				const endSyntax = "	}";

				this._write(startSyntax);
				this.writeLine();
				this._write(middleSyntax);
				this.writeLine();
				this._write(endSyntax);
				this.writeLine();
			}

			// set fieldName(fieldName: fieldType[]) {
			//	this._fieldName = fieldName;
			// }
			writeArraySetter(attribute) {
				const startSyntax = `	set ${attribute.fieldName}(${attribute.fieldName}: ${attribute.fieldType}[]) {`;
				const middleSyntax = `		this._${attribute.fieldName} = ${attribute.fieldName}`;
				const endSyntax = `	}`;

				this._write(startSyntax);
				this.writeLine();
				this._write(middleSyntax);
				this.writeLine();
				this._write(endSyntax);
				this.writeLine();
			}

		}


		class InterfaceWriter extends Writer {

			// import { className } from 'path';
			writeImport(imp) {
				const syntax = `import { ${imp.className} } from '${imp.path}';`;

				this._write(syntax);
				this.writeLine();
			}

			// interface className {
			writeStartClass(clazz) {
				const syntax = `export interface ${clazz.className} {`;

				this._write(syntax);
				this.writeLine();
			}

			// }
			writeEndClass() {
				const syntax = "}";

				this._write(syntax);
				this.writeLine();
			}

			// fieldName: fieldType;
			writeAttribute(attribute) {
				const syntax = `	${attribute.fieldName}: ${attribute.fieldType};`;

				this._write(syntax);
				this.writeLine();
			}

			// fieldName: Array<fieldType>;
			writeArrayAttribute(arrayAttribute) {
				const syntax = `	${arrayAttribute.fieldName}: Array<${arrayAttribute.fieldType}>;`;

				this._write(syntax);
				this.writeLine();
			}

		}

		class SetterWriter extends Writer {

			// const fieldName: className = new className();
			writeInstance(instance) {
				const syntax = `const ${instance.fieldName}: ${instance.className} = new ${instance.className}();`;

				this._write(syntax);
				this.writeLine();
			}

			// const fieldName: Array<fieldType> = [];
			writeArrayInstance(arrayInstance) {
				const syntax = `const ${arrayInstance.fieldName}: Array<${arrayInstance.fieldType}> = [];`;

				this._write(syntax);
				this.writeLine();
			}

			// fieldName.push(value);
			writeArraySetter(arraySetter) {
				const syntax = `${arraySetter.fieldName}.push(${arraySetter.value});`;

				this._write(syntax);
				this.writeLine();
			}

			// fieldName.methodName = value;
			writeAssignment(setter) {
				const syntax = `${setter.fieldName}.${setter.methodName} = ${setter.value};`;

				this._write(syntax);
				this.writeLine();
			}

			// fieldName.methodName = value;
			writeSetter(setter) {
				const syntax = `${setter.fieldName}.set${Utils.fixMethodName(setter.methodName)}(${setter.value});`;

				this._write(syntax);
				this.writeLine();
			}

		}

		class IOUtils {

			static downloadText(fileName, text) {
				this.download(fileName, text, "text/plain");
			}

			static download(fileName, content, type) {
				const contentAsBlob = new Blob([content], { type: type });
				this._downloadLink = document.createElement("a");
				this._downloadLink.download = fileName;
				this._downloadLink.href = window.URL.createObjectURL(contentAsBlob);
				this._downloadLink.click();
			}

		}

		class Utils {

			static getListFieldName(fieldName, value) {
				if (fieldName) {
					return Array.isArray(value) ? fieldName.concat("List") : fieldName.replace("List", "");
				}
			}

			static getNumberFromString(str) {
				if (str) {
					return str.match(/\d+/);
				}
			}

			static isEmpty(obj) {
				return !obj || obj.length == 0;
			}

			static getClassName(name) {
				let result;
				if (name) {
					result = name.charAt(0).toUpperCase();
					if (name.length > 1) {
						result += name.substring(1);
					}
				}
				return result;
			}

			static getType(val) {
				return val ? typeof val : "string";
			}

			static fixFieldName(name) {
				let result;
				if (name) {
					result = name.charAt(0).toLowerCase();
					if (name.length > 1) {
						result += name.substring(1);
					}
				}
				return result;
			}

			static fixValue(val, useOnlyStringDataType) {
				let valFixed;
				if (!val) {
					valFixed = "''";
				} else if (useOnlyStringDataType || typeof val == "string") {
					valFixed = "'" + val + "'";
				} else {
					valFixed = val;
				}
				return valFixed;
			}

			static fixMethodName(name) {
				let result;
				if (name) {
					result = name.charAt(0).toUpperCase();
					if (name.length > 1) {
						result += name.substring(1);
					}
				}
				return result;
			}

			static isBlank(val) {
				return val ? val.indexOf(" ") != -1 : true;
			}

			static isObject(val) {
				return typeof val == "object";
			}

			static parseJson(json) {
				try {
					const jsonParsed = JSON.parse(json);
					if (jsonParsed && this.isObject(jsonParsed)) {
						return jsonParsed;
					}
				}
				catch (e) {
					console.error(e);
				}
			}

			static isBase64(str) {
				try {
					return str ? btoa(atob(str)) == str : false;
				} catch (e) {
					return false;
				}
			}

		}

		class GeneratorHelper {

			constructor() {
				this._options;
				this._writer;
			}

			generateSetters(json, rootName) {
				return this._generate(json, rootName, new SetterGenerator(this._options, this._writer));
			}

			generateClass(json, rootName) {
				return this._generate(json, rootName, new ClassGenerator(this._options, this._writer));
			}

			_generate(json, rootName, generator) {
				let jsonParsed;
				if (jsonParsed = Utils.parseJson(json)) {
					try {
					generator.create(jsonParsed, rootName);
					return generator.build();
					} catch (e) {
						showError("The generator failed to generate the code.");
					}
				} else {
					showError("Invalid JSON was detected.");
				}
			}

			set options(options) {
				this._options = options;
			}

			set writer(writer) {
				this._writer = writer;
			}

		}

		function getSelectedOption(componentName) {
			if (componentName) {
				const components = document.getElementsByName(componentName);
				for (let i = 0; i < components.length; i++) {
					const component = components[i];
					if (component.checked)
						return component.value;
				}

			}
			return "";
		}

		function showError(message) {
			showMessage("Error: " + message);
			throw new Error(message);
		}

		function showMessage(message) {
			alert(message);
		}

		function fillOptions(classOptions) {
			if (classOptions.supportArrayInstantiation) {
				classOptions.arrayInstantiation = getSelectedOption("array-instantiation");
			}
			if (classOptions.supportAssignment) {
				classOptions.assignment = getSelectedOption("assignments");
			}
			if (classOptions.supportStrigDataType) {
				classOptions.stringDataType = getSelectedOption("string-data-type");
			}
			if (classOptions.supportEmptyString) {
				classOptions.emptyString = getSelectedOption("empty-string");
			}
			if (classOptions.supportEncryptionAnnotation) {
				classOptions.encryption = getSelectedOption("encryptionAnnotation");
				classOptions.encryptionPath = document.getElementById("encryptionAnnotationPath").value;
			}
			return classOptions;
		}

		function updateOptions(generatorType) {
			let options;

			if (generatorType == "setter") {
				options = new SetterOptions();
			} else if (generatorType == "class") {
				options = new ClassOptions();
			} else if (generatorType == "interface") {
				options = new InterfaceOptions();
			} else {
				showError('Generator was not found.');
			}

			assignmentOption.style.display = options.supportAssignment() ? "initial" : "none";
			arrayInstantiationOption.style.display = options.supportArrayInstantiation() ? "initial" : "none";
			stringDataTypeOption.style.display = options.supportStrigDataType() ? "initial" : "none";
			emptyStringOption.style.display = options.supportEmptyString() ? "initial" : "none";
			encryptionAnnotationOption.style.display = options.supportEncryptionAnnotation() ? "initial" : "none";
		}

		function generate(generatorType) {
			const generator = new GeneratorHelper();

			if (generatorType == "setter") {
				generator.writer = new SetterWriter();
				generator.options = fillOptions(new SetterOptions());
				contents = generator.generateSetters(jsonInput.value, rootClassInput.value);
			} else if (generatorType == "class") {
				generator.writer = new ClassWriter();
				generator.options = fillOptions(new ClassOptions());
				contents = generator.generateClass(jsonInput.value, rootClassInput.value);
			} else if (generatorType == "interface") {
				generator.writer = new InterfaceWriter();
				generator.options = fillOptions(new InterfaceOptions());
				contents = generator.generateClass(jsonInput.value, rootClassInput.value);
			} else {
				showError('Generator was not found.');
			}
		}

		function hasContents() {
			return contents && contents.length > 0;
		}

		function printContentsToConsole() {
			if (!hasContents()) {
				showError("No content was generated.");
			}

			contents.forEach(content => resultInput.value += content.text);
		}

		function downloadContents() {
			if (!hasContents()) {
				showError("No content found.");
			}

			contents.forEach(content => IOUtils.downloadText(`${content.name}.ts`, content.text));
		}

		function clearAllSelections() {
			if (window.getSelection) {
				window.getSelection().removeAllRanges();
			} else if (document.selection) {
				document.selection.empty();
			}
		}

		function copySelection(element) {
			if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {
				element.select();
				document.execCommand("Copy");
			} else {
				showError("Cannot copy the selected content.")
			}
		}

		function resetFields() {
			rootClassInput.value = "";
			jsonInput.value = "";
			resultInput.value = "";
			rootClassInput.focus();
		}

		function clearConsole() {
			resultInput.value = "";
		}

		generateBtn.addEventListener("click", function () {
			clearConsole();
			generate(getSelectedOption("generatorType"));
			printContentsToConsole();
		});

		downloadBtn.addEventListener("click", function () {
			downloadContents();
		});

		clearBtn.addEventListener("click", function () {
			resetFields();
		});

		copyBtn.addEventListener("click", function () {
			copySelection(resultInput);
			clearAllSelections();
		});

		generatorTypeSelect.addEventListener("change", function (e) {
			updateOptions(e.target.value);
		});

		updateOptions(getSelectedOption("generatorType"));

	</script>

</body>

</html>